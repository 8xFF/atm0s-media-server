// This file is @generated by prost-build.
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Request {
    #[prost(uint32, tag = "1")]
    pub req_id: u32,
    #[prost(oneof = "request::Request", tags = "2, 3, 4, 5, 6")]
    pub request: ::core::option::Option<request::Request>,
}
/// Nested message and enum types in `Request`.
pub mod request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Session {
        #[prost(oneof = "session::Request", tags = "1, 2, 3, 4")]
        pub request: ::core::option::Option<session::Request>,
    }
    /// Nested message and enum types in `Session`.
    pub mod session {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RoomJoin {
            #[prost(message, optional, tag = "1")]
            pub info: ::core::option::Option<super::super::super::shared::RoomJoin>,
            #[prost(string, tag = "2")]
            pub token: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RoomLeave {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UpdateSdp {
            #[prost(message, optional, tag = "1")]
            pub tracks: ::core::option::Option<super::super::super::shared::Tracks>,
            #[prost(string, tag = "2")]
            pub sdp: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Disconnect {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Request {
            #[prost(message, tag = "1")]
            Join(RoomJoin),
            #[prost(message, tag = "2")]
            Leave(RoomLeave),
            #[prost(message, tag = "3")]
            Sdp(UpdateSdp),
            #[prost(message, tag = "4")]
            Disconnect(Disconnect),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Rooom {
        #[prost(oneof = "rooom::Request", tags = "1, 2")]
        pub request: ::core::option::Option<rooom::Request>,
    }
    /// Nested message and enum types in `Rooom`.
    pub mod rooom {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SubscribePeer {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UnsubscribePeer {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Request {
            #[prost(message, tag = "1")]
            Subscribe(SubscribePeer),
            #[prost(message, tag = "2")]
            Unsubscribe(UnsubscribePeer),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sender {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(oneof = "sender::Request", tags = "2, 3, 4")]
        pub request: ::core::option::Option<sender::Request>,
    }
    /// Nested message and enum types in `Sender`.
    pub mod sender {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Attach {
            #[prost(message, optional, tag = "1")]
            pub source: ::core::option::Option<
                super::super::super::shared::sender::Source,
            >,
            #[prost(message, optional, tag = "2")]
            pub config: ::core::option::Option<
                super::super::super::shared::sender::Config,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Detach {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Request {
            #[prost(message, tag = "2")]
            Attach(Attach),
            #[prost(message, tag = "3")]
            Detach(Detach),
            #[prost(message, tag = "4")]
            Config(super::super::super::shared::sender::Config),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Receiver {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(oneof = "receiver::Request", tags = "2, 3, 4")]
        pub request: ::core::option::Option<receiver::Request>,
    }
    /// Nested message and enum types in `Receiver`.
    pub mod receiver {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Attach {
            #[prost(message, optional, tag = "1")]
            pub source: ::core::option::Option<
                super::super::super::shared::receiver::Source,
            >,
            #[prost(message, optional, tag = "2")]
            pub config: ::core::option::Option<
                super::super::super::shared::receiver::Config,
            >,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Detach {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Request {
            #[prost(message, tag = "2")]
            Attach(Attach),
            #[prost(message, tag = "3")]
            Detach(Detach),
            #[prost(message, tag = "4")]
            Config(super::super::super::shared::receiver::Config),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Request {
        #[prost(message, tag = "2")]
        Session(Session),
        #[prost(message, tag = "3")]
        Room(Rooom),
        #[prost(message, tag = "4")]
        Sender(Sender),
        #[prost(message, tag = "5")]
        Receiver(Receiver),
        #[prost(message, tag = "6")]
        Features(super::super::features::Request),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Response {
    #[prost(uint32, tag = "1")]
    pub req_id: u32,
    #[prost(oneof = "response::Response", tags = "2, 3, 4, 5, 6, 7")]
    pub response: ::core::option::Option<response::Response>,
}
/// Nested message and enum types in `Response`.
pub mod response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Session {
        #[prost(oneof = "session::Response", tags = "1, 2, 3, 4")]
        pub response: ::core::option::Option<session::Response>,
    }
    /// Nested message and enum types in `Session`.
    pub mod session {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RoomJoin {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct RoomLeave {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UpdateSdp {
            #[prost(string, tag = "1")]
            pub sdp: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Disconnect {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Join(RoomJoin),
            #[prost(message, tag = "2")]
            Leave(RoomLeave),
            #[prost(message, tag = "3")]
            Sdp(UpdateSdp),
            #[prost(message, tag = "4")]
            Disconnect(Disconnect),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Room {
        #[prost(oneof = "room::Response", tags = "1, 2")]
        pub response: ::core::option::Option<room::Response>,
    }
    /// Nested message and enum types in `Room`.
    pub mod room {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct SubscribePeer {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct UnsubscribePeer {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Subscribe(SubscribePeer),
            #[prost(message, tag = "2")]
            Unsubscribe(UnsubscribePeer),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sender {
        #[prost(oneof = "sender::Response", tags = "1, 2, 3")]
        pub response: ::core::option::Option<sender::Response>,
    }
    /// Nested message and enum types in `Sender`.
    pub mod sender {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Attach {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Detach {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Config {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Attach(Attach),
            #[prost(message, tag = "2")]
            Detach(Detach),
            #[prost(message, tag = "3")]
            Config(Config),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Receiver {
        #[prost(oneof = "receiver::Response", tags = "1, 2, 3")]
        pub response: ::core::option::Option<receiver::Response>,
    }
    /// Nested message and enum types in `Receiver`.
    pub mod receiver {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Attach {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Detach {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Config {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Response {
            #[prost(message, tag = "1")]
            Attach(Attach),
            #[prost(message, tag = "2")]
            Detach(Detach),
            #[prost(message, tag = "3")]
            Config(Config),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Response {
        #[prost(message, tag = "2")]
        Error(super::super::shared::Error),
        #[prost(message, tag = "3")]
        Session(Session),
        #[prost(message, tag = "4")]
        Room(Room),
        #[prost(message, tag = "5")]
        Sender(Sender),
        #[prost(message, tag = "6")]
        Receiver(Receiver),
        #[prost(message, tag = "7")]
        Features(super::super::features::Request),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ServerEvent {
    #[prost(uint32, tag = "1")]
    pub seq: u32,
    #[prost(oneof = "server_event::Event", tags = "2, 3, 4, 5, 6, 7")]
    pub event: ::core::option::Option<server_event::Event>,
}
/// Nested message and enum types in `ServerEvent`.
pub mod server_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Session {
        #[prost(oneof = "session::Event", tags = "1, 2, 3, 4, 5")]
        pub event: ::core::option::Option<session::Event>,
    }
    /// Nested message and enum types in `Session`.
    pub mod session {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Connected {}
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct JoinedRoom {
            #[prost(string, tag = "1")]
            pub room: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub peer: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct LeavedRoom {
            #[prost(string, tag = "1")]
            pub room: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub peer: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Disconnected {
            #[prost(string, tag = "1")]
            pub reason: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct GoAway {
            #[prost(string, tag = "1")]
            pub reason: ::prost::alloc::string::String,
            #[prost(uint32, tag = "2")]
            pub remain_seconds: u32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(message, tag = "1")]
            Connected(Connected),
            #[prost(message, tag = "2")]
            Joined(JoinedRoom),
            #[prost(message, tag = "3")]
            Leaved(LeavedRoom),
            #[prost(message, tag = "4")]
            Disconnected(Disconnected),
            #[prost(message, tag = "5")]
            Goway(GoAway),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Room {
        #[prost(oneof = "room::Event", tags = "1, 2, 3, 4, 5, 6")]
        pub event: ::core::option::Option<room::Event>,
    }
    /// Nested message and enum types in `Room`.
    pub mod room {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PeerJoined {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
            #[prost(string, optional, tag = "2")]
            pub metadata: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PeerUpdated {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
            #[prost(string, optional, tag = "2")]
            pub metadata: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct PeerLeaved {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TrackStarted {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub track: ::prost::alloc::string::String,
            #[prost(enumeration = "super::super::super::shared::Kind", tag = "3")]
            pub kind: i32,
            #[prost(string, optional, tag = "4")]
            pub metadata: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TrackUpdated {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub track: ::prost::alloc::string::String,
            #[prost(enumeration = "super::super::super::shared::Kind", tag = "3")]
            pub kind: i32,
            #[prost(string, optional, tag = "4")]
            pub metadata: ::core::option::Option<::prost::alloc::string::String>,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct TrackStopped {
            #[prost(string, tag = "1")]
            pub peer: ::prost::alloc::string::String,
            #[prost(string, tag = "2")]
            pub track: ::prost::alloc::string::String,
            #[prost(enumeration = "super::super::super::shared::Kind", tag = "3")]
            pub kind: i32,
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(message, tag = "1")]
            PeerJoined(PeerJoined),
            #[prost(message, tag = "2")]
            PeerUpdated(PeerUpdated),
            #[prost(message, tag = "3")]
            PeerLeaved(PeerLeaved),
            #[prost(message, tag = "4")]
            TrackStarted(TrackStarted),
            #[prost(message, tag = "5")]
            TrackUpdated(TrackUpdated),
            #[prost(message, tag = "6")]
            TrackStopped(TrackStopped),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Sender {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(oneof = "sender::Event", tags = "2")]
        pub event: ::core::option::Option<sender::Event>,
    }
    /// Nested message and enum types in `Sender`.
    pub mod sender {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct State {
            #[prost(enumeration = "state::StateType", tag = "1")]
            pub state: i32,
        }
        /// Nested message and enum types in `State`.
        pub mod state {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum StateType {
                Waiting = 0,
                NoSource = 1,
                Active = 2,
                Inactive = 3,
            }
            impl StateType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        StateType::Waiting => "WAITING",
                        StateType::NoSource => "NO_SOURCE",
                        StateType::Active => "ACTIVE",
                        StateType::Inactive => "INACTIVE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "WAITING" => Some(Self::Waiting),
                        "NO_SOURCE" => Some(Self::NoSource),
                        "ACTIVE" => Some(Self::Active),
                        "INACTIVE" => Some(Self::Inactive),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(message, tag = "2")]
            State(State),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Receiver {
        #[prost(string, tag = "1")]
        pub name: ::prost::alloc::string::String,
        #[prost(oneof = "receiver::Event", tags = "2, 3")]
        pub event: ::core::option::Option<receiver::Event>,
    }
    /// Nested message and enum types in `Receiver`.
    pub mod receiver {
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct State {
            #[prost(enumeration = "state::StateType", tag = "1")]
            pub state: i32,
        }
        /// Nested message and enum types in `State`.
        pub mod state {
            #[derive(
                Clone,
                Copy,
                Debug,
                PartialEq,
                Eq,
                Hash,
                PartialOrd,
                Ord,
                ::prost::Enumeration
            )]
            #[repr(i32)]
            pub enum StateType {
                NoSource = 0,
                Waiting = 1,
                Live = 2,
                KeyOnly = 3,
                Inactive = 4,
            }
            impl StateType {
                /// String value of the enum field names used in the ProtoBuf definition.
                ///
                /// The values are not transformed in any way and thus are considered stable
                /// (if the ProtoBuf definition does not change) and safe for programmatic use.
                pub fn as_str_name(&self) -> &'static str {
                    match self {
                        StateType::NoSource => "NO_SOURCE",
                        StateType::Waiting => "WAITING",
                        StateType::Live => "LIVE",
                        StateType::KeyOnly => "KEY_ONLY",
                        StateType::Inactive => "INACTIVE",
                    }
                }
                /// Creates an enum from field names used in the ProtoBuf definition.
                pub fn from_str_name(value: &str) -> ::core::option::Option<Self> {
                    match value {
                        "NO_SOURCE" => Some(Self::NoSource),
                        "WAITING" => Some(Self::Waiting),
                        "LIVE" => Some(Self::Live),
                        "KEY_ONLY" => Some(Self::KeyOnly),
                        "INACTIVE" => Some(Self::Inactive),
                        _ => None,
                    }
                }
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Message)]
        pub struct Stats {
            #[prost(message, optional, tag = "1")]
            pub source: ::core::option::Option<stats::Source>,
            #[prost(message, optional, tag = "2")]
            pub transmit: ::core::option::Option<stats::Transmit>,
        }
        /// Nested message and enum types in `Stats`.
        pub mod stats {
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Source {
                #[prost(uint32, tag = "1")]
                pub bitrate_kbps: u32,
                #[prost(float, tag = "2")]
                pub rtt: f32,
                #[prost(float, tag = "3")]
                pub lost: f32,
                #[prost(float, tag = "4")]
                pub jitter: f32,
            }
            #[allow(clippy::derive_partial_eq_without_eq)]
            #[derive(Clone, PartialEq, ::prost::Message)]
            pub struct Transmit {
                #[prost(uint32, tag = "1")]
                pub spatial: u32,
                #[prost(uint32, tag = "2")]
                pub temporal: u32,
                #[prost(uint32, tag = "3")]
                pub bitrate_kbps: u32,
            }
        }
        #[allow(clippy::derive_partial_eq_without_eq)]
        #[derive(Clone, PartialEq, ::prost::Oneof)]
        pub enum Event {
            #[prost(message, tag = "2")]
            State(State),
            #[prost(message, tag = "3")]
            Stats(Stats),
        }
    }
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "2")]
        Session(Session),
        #[prost(message, tag = "3")]
        Room(Room),
        #[prost(message, tag = "4")]
        Sender(Sender),
        #[prost(message, tag = "5")]
        Receiver(Receiver),
        #[prost(message, tag = "6")]
        Response(super::Response),
        #[prost(message, tag = "7")]
        Features(super::super::features::ServerEvent),
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ClientEvent {
    #[prost(uint32, tag = "1")]
    pub seq: u32,
    #[prost(oneof = "client_event::Event", tags = "2")]
    pub event: ::core::option::Option<client_event::Event>,
}
/// Nested message and enum types in `ClientEvent`.
pub mod client_event {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Event {
        #[prost(message, tag = "2")]
        Request(super::Request),
    }
}
