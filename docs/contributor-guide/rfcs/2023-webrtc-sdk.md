# 2023 WebRTC SDK

- RFC Number: RFC-WebRTCSdk-2023
- Author: [giangndm](https://github.com/giangndm)
- Status: Draft
- Date: 2023-01-01

## Abstract

This RFC describes how WebRTC client is connect to atm0s-media-server and how it works.

## Motivation

We need to create a client sdk which can be used in any platform and can be customized to fit with any use case. This sdk should be easy to use and easy to customize. It also need to work-well with atm0s-media-server network topology and our aproach to handle media stream.

## Proposal

For simplicty we proposal a sdk protocol which only use with HTTP (not websocket) and WebRTC.

- HTTP is only used for sending RPC request to cluster (typicaly is Connect and Retry phase).
- WebRTC is used for sending and receiving media stream and also rpc, event after connected.

### HTTP Request/Response format

All request and response will be encoded in JSON format. The format is described as below:

Request: JSON

Response:

```json
{
    status: bool,
    error: Option<String>,
    data: Option<JSON>,
}
```

### Connect request

Client can prepare some senders or receivers before connect to server. When client connect to server, it will send a connect request to server.

Client must to prepare:

- WebRTC connection with datachannel enabled.
- List of senders and receivers.
- WebRTC OfferSDP.

Endpoint: `GATEWAY/webrtc/connect`

```json
{
    version: Option<String>,
    room: String,
    peer: String,
    sub_scope: "manual" | "full" | "stream_only",
    pub_scope: "full" | "stream_only",
    mix_minus_audio: "disable" | "all" | "manual",
    remote_bitrate_control_mode: "dynamic_with_consumers" | "max_bitrate_only",
    token: String,
    receivers: {
        audio: Number,
        video: Number
    },
    senders: [
        {
            kind: "audio" | "video",
            name: String,
            uuid: String,
            label: String,
            screen: Option<bool>,
        }
    ],
    sdp: Option<String>
}
```

After that server will success response with data:

```json
{
    sdp: Option<String>,
    conn_id: String,
}
```

Error list:

- Invalid token
- SDP Error
- Invalid request
- Internal server error
- Gateway error

After that client need to wait for connected event from WebRTC connection and connected event from datachannel.
If after a period of time, client don't receive any event, it will set restart ice flag and retry connect to server with newest offer-sdp. After some tries (configurable), client will stop retry and report error to user.

### Ice-tricle

Each time client WebRTC connection has a new ice-candidate, it should sending to gateway over:

Endpoint: `GATEWAY/webrtc/ice_remote`
Request:
```json
{
    conn_id: String,
    candidate: String,
}
```

Response:
```json
{
    data: "OK"
}
```


### Track identify

All track will be generated with an unique id. This id will be used to identify track in all request and response.

With sender, client free to choose id for track. But with receiver, client must to generate id same with which is generated automatically by server.

Receiver id is generated by server with format: `{kind}-{index}`. With kind is audio or video, index is current index of receiver in list of that kind receivers. Example if we have 2 audio receivers and 3 video receivers:

- audio-0
- audio-1
- video-0
- video-1
- video-2

### Datachannel Request/Response format

All request and response sending over datachannel will be encoded in JSON format. The format is described as below:

Request:
```json
{
    type: "event" | "request",
    req_id: Number,
    request: String,
    data: Option<JSON>,
}
```

Response:

```json
{
    req_id: Number,
    type: "answer",
    success: bool,
    error: Option<String>,
    data: Option<JSON>,
}
```

### In-session requests

At current state, we will have only one WebRTC connection to server. So we don't need to send any request to server. All request will be send over datachannel.

Typicaly, client will need some actions with media server:

- Create/Release sender
- Create/Release receiver
- Sender action: pause, resume, switch stream
- Receiver action: pause, resume, switch remote source, update priority and layers

All action which changed streams will be do at local-first, then calling updateSdp to server.

#### Sender create/release, actions, events

For create a sender we need to create a transiver with kind is audio or video. After that we need to create a track and add it to transiver. Then we need to sending updateSdp request to server. 

For destroy a sender, we need to remove track from transiver and remove transiver from connection. Then we need to sending updateSdp request to server.

Each sender support bellow actions:

```
Request: sender.toggle
Request data:
{
    name: String,
    kind: "audio" | "video",
    track: Option<String>,
    label: Option<String>,
}
Response: boolean
```

Each sender has bellow events:

```
Event: 
Event data:
{

}
```


#### Receiver create/release, actions

For create a receiver we need to create a transiver with kind is audio or video. After that we need to create a track and add it to transiver. Then we need to sending updateSdp request to server.

Each receiver support bellow actions:

```
Request: receiver.switch
Request data:
{
    id: String,
    priority: u16,
    remote: {
        peer: String,
        stream: String,
    },
}
Response: boolean
```

```
Request: receiver.limit
Request data:
{
    id: String,
    limit: ReceiverLayerLimit,
}
Response: boolean
```

```
Request: receiver.disconnect
Request data:
{
    id: String,
}
Response: boolean
```

Each sender has bellow events:

```
Event: 
Event data:
{
    
}
```

#### UpdateSDP

Each time we changed something in WebRTC connection, we need to send updateSdp request to server over datachannel. The request will be described in below:

request: `peer.updateSdp`
Request data: 
```json
{
    sdp: String,
    receivers: {
        audio: Number,
        video: Number
    },
    senders: [
        {
            kind: "audio" | "video",
            name: String,
            uuid: String,
            label: String,
            screen: Option<bool>,
        }
    ],
}
```

Response data:
```json
{
    sdp: String
}
```

## Implementation Details

Describe the technical implementation details, including any code snippets or diagrams if necessary.

## Potential Impact and Risks

Discuss the potential impact and risks associated with the proposed changes.

## Alternatives Considered

List any alternative approaches that were considered and why they were not chosen.

## Open Questions

Highlight any open questions or concerns that need to be addressed.

## References

List any relevant references or resources.

## Appendix

Include any additional information or supporting materials.
