# Cluster [RFC-0003-media-global-cluster](https://github.com/8xFF/rfcs/pull/3)

Atm0s Media Server supports cluster mode out of the box. All nodes in the cluster will automatically discover each other and route requests to the best node.

We can have multiple gateway nodes and multiple media-server nodes in a cluster, which ensures high availability and scalability. We also don't need any persistent database for the cluster; all data will be stored in memory with the help of decentralized key-value. In case the node holding the data is down, the data will be automatically synced to other nodes in the cluster after a while. The logic behind this is similar to [Kademlia DHT](https://en.wikipedia.org/wiki/Kademlia), where the node for each key is selected and routed by the XOR operator.

We can run in single zone or multi zones.

![Single zone](../../imgs/single-zone.excalidraw.png)

![Multi zones](../../imgs/multi-zones.excalidraw.png)

With multi-zones setup, we have 2 options for the structure of the cluster: Flat-structure and Geo-location based.

### Flat-structure

In flat-structure, we have max 256 zones, each zone has 256 nodes. In this mode, we will use zone-id with prefix: 0x0000XX, for example, we have 2 zones, we can config like:

| Zone name | Zone ID  |
| --------- | -------- |
| US 1      | 0x000001 |
| US 2      | 0x000002 |
| EU 1      | 0x000003 |
| EU 2      | 0x000004 |
| AP 1      | 0x000005 |
| AP 2      | 0x000006 |

### Geo-location based

Geo-location based is a more complex setup, we can have more than 256 zones. In this structure each zone is attach with an location info, and this help us can route between zone effectively if we have move than 256 zones.

Zone-id prefix will be generated by rule: 0xAABBCC, where:

- AA: is Latitude split to 16 parts and Longitude split to 16 parts
- BB: is AA zone split agent to 16 parts Latitude and Longitude
- CC: is the zone index in the zone

Bellow is pregenerated zone-id for some AWS regions:

| Zone name      | City           | Lat-Long       | Zone ID Prefix |
| -------------- | -------------- | -------------- | -------------- |
| us-east-1      | Virginia       | 38.13, -78.45  | 0xB499         |
| us-east-2      | Ohio           | 39.96, -83     | 0xB4C5         |
| us-west-1      | California     | 37.35, -121.96 | 0xB27A         |
| us-west-2      | Oregon         | 46.15, -123.88 | 0xC228         |
| eu-west-1      | Ireland        | 53, -8         | 0xC7FB         |
| eu-west-2      | London         | 51, -0.1       | 0xC8C0         |
| eu-west-3      | Paris          | 48.86, 2.35    | 0xC871         |
| eu-central-1   | Frankfurt      | 50.0, 8.0      | 0xC8A6         |
| sa-east-1      | Sao Paulo      | -23.34, -46.38 | 0x55FF         |
| ap-southeast-1 | Singapore      | 1.37, 103.8    | 0x8C2B         |
| ap-southeast-2 | Sydney         | -33.86, 151.2  | 0x5E0D         |
| ap-northeast-1 | Tokyo          | 35.41, 139.42  | 0xBE33         |
| ap-northeast-2 | Seoul          | 37.56, 126.98  | 0xBD7B         |
| ap-south-1     | Mumbai         | 19.08, 72.88   | 0x9BF4         |
| ca-central-1   | Canada Central | 45.5, -73.6    | 0xC41D         |

[Zone generate utils here](https://play.rust-lang.org/?version=stable&mode=debug&edition=2021&gist=2c4a19e2c10a39b47d618c70b050cee1)

or source here:

```rust
fn geo_to_zone(lat: f64, lon: f64) -> u16 {
    const SPARE_LAT: u32 = (180 * 4) / 16;
    const SPARE_LON: u32 = (360 * 4) / 16;

    let lat_u32 = ((lat + 90.0) * 4.0).round() as u32;
    let lon_u32 = ((lon + 180.0) * 4.0).round() as u32;

    let mut geo1_lat = lat_u32 / SPARE_LAT;
    let mut geo1_lon = lon_u32 / SPARE_LON;

    if geo1_lat > 15 {
        geo1_lat = 15;
    }

    if geo1_lon > 15 {
        geo1_lon = 15;
    }

    let geo1 = ((geo1_lat << 4) | geo1_lon) << 8;

    const SPARE_LAT_SMALL: u32 = SPARE_LAT / 16;
    const SPARE_LON_SMALL: u32 = SPARE_LON / 16;

    let remain_lat = lat_u32 % SPARE_LAT;
    let remain_lon = lon_u32 % SPARE_LON;

    let mut geo1_lat_small = remain_lat / SPARE_LAT_SMALL;
    let mut geo1_lon_small = remain_lon / SPARE_LON_SMALL;

    if geo1_lat_small > 15 {
        geo1_lat_small = 15;
    }

    if geo1_lon_small > 15 {
        geo1_lon_small = 15;
    }

    let geo2 = (geo1_lat_small << 4) | geo1_lon_small;
    (geo1 | geo2) as u16
}

fn main() {
    println!("GeoIndex: 0x{:X}", geo_to_zone(45.5, -73.6));
}
```
